package ccjava.diffparser;

import java.io.File;
import java.io.IOException;
import java.nio.charset.Charset;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.List;

import org.apache.commons.io.FileUtils;
import org.apache.commons.io.filefilter.SuffixFileFilter;
import org.apache.commons.io.filefilter.TrueFileFilter;

import ccjava.DEFINES;

/**
 * Parses diff files generated by git-diff. Those diff files follow the unified diff format. 
 * Only additions and changes are considered, i.e. deletions are ignored.
 */
public class GitDiffParser {
	private Charset DEFAULT_ENCODING = Charset.defaultCharset();
	private String JAVA_PATCH_FILE_SUFFIX = ".java.patch";
	private String PATCH_FILE_SUFFIX = ".patch";
	
	private Path sourceDir;

	public GitDiffParser(Path sourceDir) {
		this.sourceDir = sourceDir;
	}
	
	public List<UnifiedDiffRegion> parse() throws IOException {
		List<UnifiedDiffRegion> diffs = new ArrayList<UnifiedDiffRegion>();
		
		if (DEFINES.LOG_DIFFS) {
			System.out.println("\n*** Extracting diffs");
		}
		
		File root = sourceDir.toFile();
		for (File f : FileUtils.listFiles(root, new SuffixFileFilter(JAVA_PATCH_FILE_SUFFIX), TrueFileFilter.INSTANCE)) {
			diffs.addAll(parsePatch(f));
		}
		
		return diffs;
	}
	
	private List<UnifiedDiffRegion> parsePatch(File patchFile) throws IOException {
		String patchFilePath = patchFile.getCanonicalPath();
		String filePathStr = patchFilePath.substring(0, patchFilePath.length() - PATCH_FILE_SUFFIX.length());
		Path filePath = Paths.get(filePathStr);
		Path relativeFilePath = getRelativePath(filePath);
		
		if (DEFINES.LOG_DIFFS) {
			System.out.println("parsing patch file: " + relativeFilePath);
		}

		List<UnifiedDiffRegion> diffs = new ArrayList<UnifiedDiffRegion>();
		List<String> patchLines = readLines(patchFile, DEFAULT_ENCODING);
		
		List<String> changeHunk = null;
		for (String line : patchLines) {
			if (line.startsWith("@@")) {
				if (changeHunk != null) { // parse current change hunk before processing another one
					diffs.addAll(parseChangeHunk(relativeFilePath.toString(), changeHunk));
				}
				
				changeHunk = new ArrayList<String>();
				changeHunk.add(line);
			} else {
				if (changeHunk != null) { // ignore everything before change hunks
					changeHunk.add(line);
				}
			}
		}
		
		// Parse last change hunk
		if (changeHunk != null) {
			diffs.addAll(parseChangeHunk(relativeFilePath.toString(), changeHunk));
		}
		
		return diffs;
	}
	
	private Path getRelativePath(Path filePath) throws IOException {
		java.nio.file.Path nioSourceDirPath = this.sourceDir.normalize().toRealPath();
		java.nio.file.Path nioFilePath = filePath.normalize().toRealPath();
		return nioSourceDirPath.relativize(nioFilePath);
	}

	private List<UnifiedDiffRegion> parseChangeHunk(String relativeFilePath, List<String> changeHunkStrList) {
		ChangeHunkHeader header = ChangeHunkHeader.parseChangeHunkHeader(changeHunkStrList.get(0));
		if (header.isDeletedFile()) {
			return new ArrayList<UnifiedDiffRegion>();
		}
		
		List<String> bodyStrList = changeHunkStrList.subList(1, changeHunkStrList.size());
		ChangeHunkBody body = ChangeHunkBody.parseChangeHunkBody(header, relativeFilePath, bodyStrList);
		
		return body.getDiffs();
	}
	
	private List<String> readLines(File f, Charset encoding) {
		List<String> fileData = null;
		try {
			fileData = FileUtils.readLines(f, encoding);
		} catch (IOException e) {
			throw new RuntimeException(e);
		}
		return fileData;
	}
}
